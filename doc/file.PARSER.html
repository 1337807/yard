<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <meta name="Content-Type" content="text/html; charset=UTF-8" />
    <title></title>
    <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />
    <link rel="stylesheet" href="css/common.css" type="text/css" media="screen" charset="utf-8" />
    
    <script type="text/javascript" charset="utf-8">
      relpath = '';
      if (relpath != '') relpath += '/';
    </script>
    <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/autocomplete.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/app.js"></script>
  </head>
  <body>
    <div id="header">
      <div id="menu">
  
    <a href="glossary.html" title="Glossary">Glossary</a> :: 
    File: PARSER
  
</div>

      <div id="search">
        <a id="class_list_link" href="#">Namespace List</a> |
        <a id="method_list_link" href="#">Method List</a> |
        <a id ="file_list_link" href="#">File List</a>
      </div>
      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><div id='filecontents'><h1>Parser Architecture</h1>

<p>The parser component of YARD is the first component in the data processing pipeline
that runs before any handling is done on the source. The parser is meant to translate
the source into a set of statements that can be understood by the <a href="file.HANDLERS.html" title="Handlers">Handlers</a>
that run immediately afterwards.</p>

<p>The important classes are described in the class diagram of the entire parser
system below:</p>

<p><img src="images/parser-class-diagram.png" alt="Parser Class Diagram" /></p>

<p>(Note: the RubyToken classes are omitted from the diagram)</p>

<h2>SourceParser</h2>

<p>The main class <tt><a href="YARD/Parser/SourceParser.html" title="YARD::Parser::SourceParser">YARD::Parser::SourceParser</a></tt> acts as a factory class, instantiating
the correct parser class given the source type being parsed. This usually involves
a file extension check, though this can be overriden. Currently, only a Ruby source
parser is implemented, though future plans include a C parser for Ruby extensions.</p>

<p>This factory class should always be used when parsing source files rather than
the individual parser classes since it initiates the pipeline that runs the
handlers on the parsed source. The parser used must also match the handlers,
and this is coordinated by the <code>SourceParser</code> class as well.</p>

<h2>Using the SourceParser Class</h2>

<p>The <code>SourceParser</code> class API is optimized for parsing globs of files. As such,
the main method to use the class is the <code>parse</code> class method, which takes an
array of file globs or a single file glob.</p>

<pre class="code"><span class='const'>YARD</span><span class='op'>::</span><span class='const'>Parser</span><span class='op'>::</span><span class='const'>SourceParser</span><span class='period'>.</span><span class='id parse'>parse</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>spec_*.rb</span><span class='tstring_end'>'</span></span><span class='rparen'>)</span>
<span class='const'>YARD</span><span class='op'>::</span><span class='const'>Parser</span><span class='op'>::</span><span class='const'>SourceParser</span><span class='period'>.</span><span class='id parse'>parse</span><span class='lparen'>(</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>spec_*.rb</span><span class='tstring_end'>'</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>*_helper.rb</span><span class='tstring_end'>'</span></span><span class='rbracket'>]</span><span class='rparen'>)</span>
</pre>

<p>This is equivalent to the convenience method <tt><a href="YARD.html#parse-class_method" title="YARD.parse">YARD.parse</a></tt>:</p>

<pre class="code"><span class='const'>YARD</span><span class='period'>.</span><span class='id parse'>parse</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>lib/**/*.rb</span><span class='tstring_end'>'</span></span><span class='rparen'>)</span>
</pre>

<p>In some cases (ie. for testing), it may be more helpful to parse a string of input
directly. In such a case, the method <tt><a href="YARD/Parser/SourceParser.html#parse_string-class_method" title="YARD::Parser::SourceParser.parse_string">YARD::Parser::SourceParser.parse_string</a></tt> should be
used:</p>

<pre class="code"><span class='const'>YARD</span><span class='op'>::</span><span class='const'>Parser</span><span class='op'>::</span><span class='const'>SourceParser</span><span class='period'>.</span><span class='id parse_string'>parse_string</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>def method(a, b) end</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
</pre>

<p>Because no filename information is given, this method allows the setting of the
parser type as an argument:</p>

<pre class="code"><span class='comment'># Parses a string of C (not implemented)
</span><span class='const'>YARD</span><span class='op'>::</span><span class='const'>Parser</span><span class='op'>::</span><span class='const'>SourceParser</span><span class='period'>.</span><span class='id parse_string'>parse_string</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>int main() { }</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='symbol'>:c</span><span class='rparen'>)</span>
</pre>

<h2>The Two Ruby Parser Types</h2>

<p>When parsing Ruby, the SourceParser can either instantiate the new <tt><a href="YARD/Parser/Ruby/RubyParser.html" title="YARD::Parser::Ruby::RubyParser">YARD::Parser::Ruby::RubyParser</a></tt>
class or the <tt><a href="YARD/Parser/Ruby/Legacy/StatementList.html" title="YARD::Parser::Ruby::Legacy::StatementList">YARD::Parser::Ruby::Legacy::StatementList</a></tt> class. The first of the
two, although faster, more robust and more efficient, is only available for
Ruby 1.9. The legacy parser parser is available in both 1.8.x and 1.9, if
compatibility is required. The choice of parser will affect which handlers
ultimately get used, since new handlers can only use the new parser and the
same requirement applies to the legacy parser &amp; handlers.</p>

<h2>Switching to Legacy Parser</h2>

<p>By default, running YARD under Ruby 1.9 will automatically select the new parser
and new handlers by extension. Although YARD supports both handler styles, plugins
may choose to only implement one of the two (though this is not recommended). If
only the legacy handlers are implemented, the <code>SourceParser</code> class should force
the use of the legacy parser by setting the <code>parser_type</code> attribute as such:</p>

<pre class="code"><span class='const'>YARD</span><span class='op'>::</span><span class='const'>Parser</span><span class='op'>::</span><span class='const'>SourceParser</span><span class='period'>.</span><span class='id parser_type'>parser_type</span> <span class='op'>=</span> <span class='symbol'>:ruby18</span>
</pre>

<p>The default value is <code>:ruby</code>. Note that this cannot be forced the other way around,
a parser type of <code>:ruby</code> cannot be set under Ruby 1.8.x as the new parser is not
supported under 1.8.</p>

<h1>RubyParser (the New Parser)</h1>

<p>The new Ruby parser uses the Ripper library that is packaged as part of stdlib
in Ruby 1.9. Because of this, it can generate an AST from a string of Ruby input
that is similar to the style of other sexp libraries (such as ParseTree). Each
node generated in the tree is of the base type <tt><a href="YARD/Parser/Ruby/AstNode.html" title="YARD::Parser::Ruby::AstNode">YARD::Parser::Ruby::AstNode</a></tt>,
which has some subclasses for common node types.</p>

<h2>AstNode Basics</h2>

<p>The <code>AstNode</code> class behaves like a standard Array class in which all of its data
make up the list of elements in the array. Unlike other sexp style libraries, however,
the node type is not the first element of the list. Instead, the node type is defined
by the <code>#type</code> method. The following examples show some of the basic uses of <code>AstNode</code>:</p>

<pre class="code"><span class='comment'># The sexp defines the statement `hello if 1`
</span><span class='id node'>node</span> <span class='op'>=</span> <span class='id s'>s</span><span class='lparen'>(</span><span class='symbol'>:if_mod</span><span class='comma'>,</span> <span class='id s'>s</span><span class='lparen'>(</span><span class='symbol'>:int</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>1</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='comma'>,</span> <span class='id s'>s</span><span class='lparen'>(</span><span class='symbol'>:var_ref</span><span class='comma'>,</span> <span class='id s'>s</span><span class='lparen'>(</span><span class='symbol'>:ident</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>hello</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='rparen'>)</span><span class='rparen'>)</span>
<span class='id node'>node</span><span class='period'>.</span><span class='id type'>type</span>  <span class='comment'>#=&gt; :if_mod
</span><span class='id node'>node</span><span class='lbracket'>[</span><span class='int'>0</span><span class='rbracket'>]</span>    <span class='comment'>#=&gt; s(:int, &quot;1&quot;)
</span><span class='id node'>node</span><span class='lbracket'>[</span><span class='int'>0</span><span class='rbracket'>]</span><span class='lbracket'>[</span><span class='int'>0</span><span class='rbracket'>]</span> <span class='comment'>#=&gt; &quot;1&quot;
</span></pre>

<p>(Note the <code>s()</code> syntax is shorthand for <code>AstNode.new(...)</code>. <code>s()</code> with no type
is shorthand for a node of type <code>:list</code>)</p>

<p>As shown, not all of the elements are AstNodes in themselves, some are String
objects containing values. A list of only the AstNodes within a node can be
accessed via the <tt><a href="YARD/Parser/Ruby/AstNode.html#children-instance_method" title="#children">#children</a></tt> method. Using
the sexp declared above, we can do:</p>

<pre class="code"><span class='id node'>node</span><span class='period'>.</span><span class='id children'>children</span> <span class='comment'>#=&gt; [s(:int, &quot;1&quot;), s(:var_ref, s(:ident, &quot;hello&quot;))]
</span></pre>

<h2>AstNode#source and #line</h2>

<p>Every node defines the <code>#source</code> method which returns the source code that the
node represents. One of the most common things to do with a node is to grab its
source. The following example shows how this can be done:</p>

<pre class="code"><span class='id source'>source</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>if 1 == 1 then\n  raise Exception\n end</span><span class='tstring_end'>&quot;</span></span>
<span class='id ast'>ast</span> <span class='op'>=</span> <span class='const'>YARD</span><span class='op'>::</span><span class='const'>Parser</span><span class='op'>::</span><span class='const'>Ruby</span><span class='op'>::</span><span class='const'>RubyParser</span><span class='period'>.</span><span class='id parse'>parse</span><span class='lparen'>(</span><span class='id source'>source</span><span class='rparen'>)</span><span class='period'>.</span><span class='id root'>root</span>
<span class='id ast'>ast</span><span class='lbracket'>[</span><span class='int'>0</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id condition'>condition</span><span class='period'>.</span><span class='id source'>source</span>  <span class='comment'>#=&gt; &quot;1 == 1&quot;
</span><span class='id ast'>ast</span><span class='lbracket'>[</span><span class='int'>0</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id then_block'>then_block</span><span class='period'>.</span><span class='id source'>source</span> <span class='comment'>#=&gt; &quot;raise Exception&quot;
</span></pre>

<p>Note that this only works on source parsed from the RubyParser, not sexps
declared using the <code>s()</code> syntax. This is because no source code is generated
or stored by nodes. Instead, only the character ranges are stored, which are
then looked up in the original full source string object. For example:</p>

<pre class="code"><span class='comment'># Following the code snippet above
</span><span class='id ast'>ast</span><span class='lbracket'>[</span><span class='int'>0</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id then_block'>then_block</span><span class='period'>.</span><span class='id source_range'>source_range</span> <span class='comment'>#=&gt; 17..31 
</span></pre>

<p>We can also get the line and line ranges in a similar fashion:</p>

<pre class="code"><span class='id ast'>ast</span><span class='lbracket'>[</span><span class='int'>0</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id type'>type</span>       <span class='comment'>#=&gt; :if
</span><span class='id ast'>ast</span><span class='lbracket'>[</span><span class='int'>0</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id line'>line</span>       <span class='comment'>#=&gt; 1
</span><span class='id ast'>ast</span><span class='lbracket'>[</span><span class='int'>0</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id line_range'>line_range</span> <span class='comment'>#=&gt; 1..3 (note the newlines in the source)
</span></pre>

<h2>AstNode#jump</h2>

<p>Often the AST will be such that the node we care about might be buried arbitrarily
deep in a node's hierarchy. The <tt><a href="YARD/Parser/Ruby/AstNode.html#jump-instance_method" title="YARD::Parser::Ruby::AstNode#jump">YARD::Parser::Ruby::AstNode#jump</a></tt> method exists
to quickly get at a node of a specific type in such a situation:</p>

<pre class="code"><span class='comment'># Get the first identifier in the statement
</span><span class='id ast'>ast</span> <span class='op'>=</span> <span class='id s'>s</span><span class='lparen'>(</span><span class='id s'>s</span><span class='lparen'>(</span><span class='symbol'>:int</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>1</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='comma'>,</span> <span class='id s'>s</span><span class='lparen'>(</span><span class='id s'>s</span><span class='lparen'>(</span><span class='symbol'>:var_ref</span><span class='comma'>,</span> <span class='id s'>s</span><span class='lparen'>(</span><span class='symbol'>:ident</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>hello</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='rparen'>)</span><span class='rparen'>)</span><span class='rparen'>)</span>
<span class='id ast'>ast</span><span class='period'>.</span><span class='id jump'>jump</span><span class='lparen'>(</span><span class='symbol'>:ident</span><span class='rparen'>)</span><span class='lbracket'>[</span><span class='int'>0</span><span class='rbracket'>]</span> <span class='comment'>#=&gt; &quot;hello&quot;
</span></pre>

<p>Multiple types can be searched for at once. If none are found, the original root
node is returned so that it may be chained.</p>

<h1>The Legacy Parser</h1>

<p>The goal of the legacy parser is much the same as the new parser, but it is far
more simplistic. Instead of a full-blown AST, the legacy parser simply groups
together lists of "statements" called a <tt><a href="YARD/Parser/Ruby/Legacy/StatementList.html" title="YARD::Parser::Ruby::Legacy::StatementList">YARD::Parser::Ruby::Legacy::StatementList</a></tt>.
These statement lists are made up of <tt><a href="YARD/Parser/Ruby/Legacy/Statement.html" title="YARD::Parser::Ruby::Legacy::Statement">YARD::Parser::Ruby::Legacy::Statement</a></tt> objects.
A statement is any method call condition, loop, or declaration. Each statement
may or may not have a block. In the case of a condition or loop, the block is
the inner list of statements; in the case of a method call, the block is a do
block (if provided). The statements themselves are made up of tokens, so instead
of being semantic in nature like the new parser, statements are tied directly
to the lexical tokens that make them up. To convert a statement into source, you
simply join all the tokens together (this is done through the use of <code>#to_s</code>).</p>

<p>Note that because there is little semantic parsing, the legacy parser is less
able to deal with certain Ruby syntaxes. Specifically, the <code>:if_mod</code> syntax
seen above ("hello if 1") would be considered two statements with the new parser,
but using the legacy parser it is only one statement:</p>

<pre class="code"><span class='id stmts'>stmts</span> <span class='op'>=</span> <span class='const'>ARD</span><span class='op'>::</span><span class='const'>Parser</span><span class='op'>::</span><span class='const'>Ruby</span><span class='op'>::</span><span class='const'>Legacy</span><span class='op'>::</span><span class='const'>StatementList</span><span class='period'>.</span><span class='id new'>new</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>hello if 1</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
<span class='id stmts'>stmts</span><span class='lbracket'>[</span><span class='int'>0</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id block'>block</span>       <span class='comment'>#=&gt; nil
</span><span class='id stmts'>stmts</span><span class='lbracket'>[</span><span class='int'>0</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id tokens'>tokens</span><span class='period'>.</span><span class='id to_s'>to_s</span> <span class='comment'>#=&gt; &quot;hello if 1&quot;
</span></pre>

<p>In addition, this means that most handling still needs to be done via string
manipulation and regular expression matching, making it considerably more
difficult to use in edge case scenarios.</p></div></div>
    
    <div id="footer">Powered by yard 0.2.3.5 (ruby-1.9.1)</div>
  </body>
</html>