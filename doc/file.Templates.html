<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta name="Content-Type" content="text/html; charset=UTF-8" />
    <title>File: Templates</title>
    <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />
    <link rel="stylesheet" href="css/common.css" type="text/css" media="screen" charset="utf-8" />
    
    <script type="text/javascript" charset="utf-8">
      relpath = '';
      if (relpath != '') relpath += '/';
    </script>
    <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/app.js"></script>
  </head>
  <body>
    <div id="header">
      <div id="menu">
  
    <a href="_index.html" title="Index">Index</a> &raquo; 
    <span class="title">File: Templates</span>
  
</div>

      <div id="search">
        <a id="class_list_link" href="#">Namespace List</a>
        <a id="method_list_link" href="#">Method List</a>
        <a id ="file_list_link" href="#">File List</a>
      </div>
      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><div id='filecontents'><h1>Templates Architecture</h1>

<p>Templates are the main component in the output rendering process of YARD,
which is invoked when conventional HTML/text output needs to be rendered
for a set of code objects.</p>

<h2>Design Goals</h2>

<p>The general design attempts to be as abstracted from actual content and templates
as possible. Unlike RDoc which uses one file to describe the entire template,
YARD splits up the rendering of code objects into small components, allowing
template modification for smaller subsets of a full template without having to
duplicate the entire template itself. This is necessary because of YARD's support
for plugins. YARD is designed for extensibility by external plugins, and because
of this, no one plugin can be responsible for the entire template because no
one plugin knows about the other plugins being used. For instance, if an RSpec
plugin was added to support and document specifications in class templates,
this information would need to be transparently added to the template to work
in conjunction with any other plugin that performed similar template modifications.
The design goals can be summarized as follows:</p>

<ol>
<li>Output should be able to be rendered for any arbitrary format with little
modification to YARD's source code. The addition of extra templates should
be sufficient.</li>
<li>The output rendered for an object should independently rendered data
from arbitrary sources. These independent components are called "sections".</li>
<li>Sections should be able to be inserted into any object without affecting
any existing sections in the document. This allows for easy modification
of templates by plugins.</li>
</ol>


<h2>Templates</h2>

<p>Template modules are the objects used to orchestrate the design goals listed
above. Specifically, they organize the sections and render the template contents
depending on the format.</p>

<h2>Engine</h2>

<p>The Engine class orchestrates the creation and rendering of Template modules and
handles serialization or specific rendering scenarios (like HTML). To create
a template, use the <tt><a href="YARD/Templates/Engine.html#template-class_method" title="template">template</a></tt> method. The two most
common methods used to initiate output are the <tt><a href="YARD/Templates/Engine.html#render-class_method" title="render">render</a></tt>
and <tt><a href="YARD/Templates/Engine.html#generate-class_method" title="generate">generate</a></tt> methods which generate and
optionally serialize output to a file. The latter, <code>#generate</code>, is used
specially to generate HTML documentation and copy over assets that may be
needed. For instance, an object may be rendered with:</p>

<pre class="code"><span class='const'>YARD</span><span class='op'>::</span><span class='const'>Templates</span><span class='op'>::</span><span class='const'>Engine</span><span class='period'>.</span><span class='id render'>render</span><span class='lparen'>(</span><span class='symbol'>:object</span> <span class='op'>=&gt;</span> <span class='id myobject'>myobject</span><span class='rparen'>)</span>
</pre>

<p>A set of objects may be rendered into HTML documentation by using:</p>

<pre class="code"><span class='comment'># all_objects is an array of module and class objects
</span><span class='comment'># options includes a :serializer key to copy output to the file system
</span><span class='const'>YARD</span><span class='op'>::</span><span class='const'>Templates</span><span class='op'>::</span><span class='const'>Engine</span><span class='period'>.</span><span class='id generate'>generate</span><span class='lparen'>(</span><span class='id all_objects'>all_objects</span><span class='comma'>,</span> <span class='id options'>options</span><span class='rparen'>)</span>
</pre>

<p>Note that these methods should not be called directly. The <tt><a href="YARD/CodeObjects/Base.html" title="YARD::CodeObjects::Base">YARD::CodeObjects::Base</a></tt>
class has a <tt><a href="YARD/CodeObjects/Base.html#format-instance_method" title="#format">#format</a></tt> helper method to render an
object. For instance, the above render example is equivalent to the simple
call <code>myobject.format</code>. The <code>generate</code> method is a special kind of render
and is called from the <tt><a href="YARD/CLI/Yardoc.html" title="YARD::CLI::Yardoc">YARD::CLI::Yardoc</a></tt> command line utility.</p>

<h2>Template Options</h2>

<p>A template keeps state when it is rendering output. This state is kept in
an options hash which is initially passed to it during instantiation. Some
default options set the template style (<code>:template</code>), the output format (<code>:format</code>),
and the serializer to use (<code>:serializer</code>). This options hash is modifiable
from all methods seen above. For example, initializing a template to output as
HTML instead of text can be done as follows:</p>

<pre class="code"><span class='id myobject'>myobject</span><span class='period'>.</span><span class='id format'>format</span><span class='lparen'>(</span><span class='symbol'>:format</span> <span class='op'>=&gt;</span> <span class='symbol'>:html</span><span class='rparen'>)</span>
</pre>

<h2>Serializer</h2>

<p>This class abstracts the logic involved in deciding how to serialize data to
the expected endpoint. For instance, there is both a <tt><a href="YARD/Serializers/StdoutSerializer.html" title="StdoutSerializer">StdoutSerializer</a></tt>
and <tt><a href="YARD/Serializers/FileSystemSerializer.html" title="FileSystemSerializer">FileSystemSerializer</a></tt> class for
outputting to console or to a file respectively. When endpoints with locations
are used (like files or URLs), the serializer implements the <tt><a href="YARD/Serializers/Base.html#serialized_path-instance_method" title="#serialized_path">#serialized_path</a></tt>
method. This allows the translation from a code object to its path at the endpoint,
which enables inter-document linking.</p>

<p>Rendered objects are automatically serialized using the object if present,
otherwise the rendered object is returned as a string to its parent. Nested
Templates automatically set the serializer to nil so that they return
as a String to their parent.</p>

<h2>Creating a Template</h2>

<p>Templates are represented by a directory inside the <tt><a href="YARD/Templates/Engine.html#template_paths-class_method" title="YARD::Templates::Engine.template_paths">YARD::Templates::Engine.template_paths</a></tt>
on disk. A standard template directory looks like the following tree:</p>

<pre class="code">(Assuming templates/ is a template path)
templates
`-- default
    |-- class
    |   |-- dot
    |   |   |-- setup.rb
    |   |   `-- superklass.erb
    |   |-- html
    |   |   |-- constructor_details.erb
    |   |   |-- setup.rb
    |   |   `-- subclasses.erb
    |   |-- setup.rb
    |   `-- text
    |       |-- setup.rb
    |       `-- subclasses.erb
    |-- docstring
    |   |-- html
    |   |   |-- abstract.erb
    |   |   |-- deprecated.erb
    |   |   |-- index.erb
    |   |   `-- text.erb
    |   |-- setup.rb
    |   `-- text
    |       |-- abstract.erb
    |       |-- deprecated.erb
    |       |-- index.erb
    |       `-- text.erb
</pre>

<p>The path <code>default</code> refers to the template style (:template key in options hash)
and the directories at the next level (such as <code>class</code>) refer to template
<code>:type</code> (options hash key) for a template. The next directory refers to the
output format being used defined by the <code>:format</code> template option.</p>

<p>As we saw in the above example, the format option can be set to <code>:html</code>, which
would use the <code>html/</code> directory instead of <code>text/</code>. Finally, the individual .erb
files are the sections that make up the template.</p>

<p>Note that the subdirectory <code>html/</code> is also its own "template" that inherits
from the parent directory. We will see more on this later.</p>

<h2>setup.rb</h2>

<p>Every template should have at least one <code>setup.rb</code> file that defines the
<tt><a href="YARD/Templates/Template.html#init-instance_method" title="#init">#init</a></tt> method to set the
<tt><a href="YARD/Templates/Template.html#sections-instance_method" title="#sections">#sections</a></tt> used by the template. If
a setup.rb is not defined in the template itself, there should be a template
that is inherited (via parent directory or explcitly) that sets the sections
on a newly created template.</p>

<p>A standard setup.rb file looks like:</p>

<p>  def init</p>

<pre class="code"><span class='id sections'>sections</span> <span class='symbol'>:section1</span><span class='comma'>,</span> <span class='symbol'>:section2</span><span class='comma'>,</span> <span class='symbol'>:section3</span>
</pre>

<p>  end</p>

<h2>Sections</h2>

<p>Sections are smaller components that correlate to template
fragments. Practically speaking, a section can either be a template fragment
(a conventional .erb file or other supported templating language), a method
(which returns a String) or another <tt><a href="YARD/Templates/Template.html" title="YARD::Templates::Template">YARD::Templates::Template</a></tt> (which in turn has its own
list of sections).</p>

<h2>Nested Sections</h2>

<p>Sections often require the ability to encapsulate a set of sub-sections in markup
(HTML, for instance). Rather than use heavier Template subclass objects, a more
lightweight solution is to nest a set of sub-sections as a list that follows
a section, for example:</p>

<pre class="code"><span class='kw'>def</span> <span class='id sections_for'>sections_for</span><span class='lparen'>(</span><span class='id object'>object</span><span class='rparen'>)</span> 
  <span class='lbracket'>[</span><span class='symbol'>:header</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='symbol'>:section_a</span><span class='comma'>,</span> <span class='symbol'>:section_b</span><span class='rbracket'>]</span><span class='rbracket'>]</span>
<span class='kw'>end</span>
</pre>

<p>The above example nests <code>section_a</code> and <code>section_b</code> within the <code>header</code> section.
Practically speaking, these sections can be placed in the result by <code>yield</code>ing
to them. A sample header.erb template might contain:</p>

<pre class="code">&lt;h2&gt;Header&lt;/h2&gt;
&lt;div id=&quot;contents&quot;&gt;
  &lt;%= yield %&gt;
&lt;/div&gt;
</pre>

<p>This template code would place the output of <code>section_a</code> and <code>section_b</code> within
the above div element. Using yield, we can also change the object that is being
rendered. For example, we may want to yield the first method of the class.
We can do this like so:</p>

<pre class="code">&lt;h2&gt;First method&lt;/h2&gt;
&lt;%= yield(current_object.meths.first) %&gt;
</pre>

<p>This would run the nested sections for the method object instead of the class.</p>

<h2>Inheriting Templates</h2>

<p>Parent directory templates are automatically inherited (or mixed in, to be
more accurate) by the current template. This means that the 'default/class/html'
template automatically inherits from 'default/class'. This also means that anything
defined in 'default/class/setup.rb' can be overridden by 'default/class/html/setup.rb'.</p>

<p>Since the Template module is a module, and not a class, they can be mixed in
explicitly (via include/extend) from other templates, which allows templates
to share erb files or helper logic. The 'default/class' template explicitly
mixes in the 'default/module' template, since it uses much of the same sections.
This is done with the helper <tt><a href="YARD/Templates/Template/ClassMethods.html#T-instance_method" title="T">T</a></tt> method, which
is simply a shorthand for <tt><a href="YARD/Templates/Engine.html#template-class_method" title="Engine.template">Engine.template</a></tt>.
It can then override (using standard inheritance) the sections from the module
template and insert sections pertaining to classes. This is one of the design
goals described above.</p>

<p>For instance, the first line in <code>default/class/html/setup.rb</code> is:</p>

<pre class="code"><span class='id include'>include</span> <span class='const'>T</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>default/module/html</span><span class='tstring_end'>'</span></span><span class='rparen'>)</span>
</pre>

<p>This includes the 'default/module/html', which means it also includes 'default/module'
by extension. This allows class to make use of any of module's erb files.</p>

<h2>Inserting Sections</h2>

<p>The ability to insert sections was mentioned above. The class template, for
instance, will modify the #init method to insert class specific sections:</p>

<pre class="code"><span class='kw'>def</span> <span class='id init'>init</span>
  <span class='kw'>super</span>
  <span class='id sections'>sections</span><span class='period'>.</span><span class='id place'>place</span><span class='lparen'>(</span><span class='symbol'>:subclasses</span><span class='rparen'>)</span><span class='period'>.</span><span class='id before'>before</span><span class='lparen'>(</span><span class='symbol'>:children</span><span class='rparen'>)</span>
  <span class='id sections'>sections</span><span class='period'>.</span><span class='id delete'>delete</span><span class='lparen'>(</span><span class='symbol'>:children</span><span class='rparen'>)</span>
  <span class='id sections'>sections</span><span class='period'>.</span><span class='id place'>place</span><span class='lparen'>(</span><span class='lbracket'>[</span><span class='symbol'>:constructor_details</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='const'>T</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>method_details</span><span class='tstring_end'>'</span></span><span class='rparen'>)</span><span class='rbracket'>]</span><span class='rbracket'>]</span><span class='rparen'>)</span><span class='period'>.</span><span class='id before'>before</span><span class='lparen'>(</span><span class='symbol'>:methodmissing</span><span class='rparen'>)</span>
<span class='kw'>end</span>
</pre>

<p>Observe how sections has been modified after the super method was called (the
super method would have been defined in <code>default/module/setup.rb</code>). The
custom method <tt><a href="Array.html#place-instance_method" title="Array#place">Array#place</a></tt> is added by YARD to allow sections to be inserted
before or after another section by it's given name rather than index. This
allows the overriding of templates in a way that does not depend on where
the section is located (since it may have been overriden by another module).</p>

<h2>Overriding Templates by Registering a Template Path</h2>

<p>Inheriting templates explicitly is useful when creating a customized template
that wants to take advantage of code re-use. However, most users who want
to customize YARD templates will want to override existing behaviour without
creating a template from scratch.</p>

<p>YARD solves this problem by allowing other template paths to be registered.
Because template modules are represented by a relative path such as 'default/class',
they can be found within any of the registered template paths. A new template
path is registered as:</p>

<pre class="code"><span class='const'>YARD</span><span class='op'>::</span><span class='const'>Templates</span><span class='op'>::</span><span class='const'>Engine</span><span class='period'>.</span><span class='id register_template_path'>register_template_path</span> <span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>/path/to/mytemplates</span><span class='tstring_end'>'</span></span>
</pre>

<p>At this point, any time the 'default/class' template is loaded, the template
will first be looked for inside the newly registered template path. If found,
it will be used as the template module, with the modules from the other
template paths implicitly mixed in.</p>

<p>Therefore, by using the same directory structure as a builtin YARD template,
a user can customize or override individual templates as if the old ones were
inherited. A real world example would further modify the 'default/class' template
seen above by creating such a path in our '/path/to/mytemplates' custom template
path:</p>

<pre class="code">/path/to/mytemplates/:
|-- class
|   |-- html
|   |   |-- customsection.erb
|   |-- setup.rb
</pre>

<p>The <code>setup.rb</code> file would look like:</p>

<pre class="code"><span class='kw'>def</span> <span class='id init'>init</span>
  <span class='kw'>super</span>
  <span class='id sections'>sections</span><span class='period'>.</span><span class='id push'>push</span> <span class='symbol'>:customsection</span>
<span class='kw'>end</span>
</pre>

<p>Now, when a class object is formatted as HTML, our customsection.erb will be
appended to the rendered data.</p></div></div>
    
    <div id="footer">Powered by yard 0.2.3.5 (ruby-1.9.1)</div>
  </body>
</html>