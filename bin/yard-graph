#!/usr/bin/env ruby
require File.dirname(__FILE__) + '/../lib/yard'
include YARD

Namespace.load(Namespace::DEFAULT_YARDOC_FILE)
$full = ARGV.index('--full') ? true : false
$empty_modules = ARGV.index('--empty-mixins') ? true : false
$dependencies = ARGV.index('--dependencies') ? true : false

def s(n) '  ' * n end
def idname(m) m.gsub('::', '_') end
def ismod(a) return '' unless $full; Namespace.at(a) ? Namespace.at(a).type.to_s : 'class' end
def consts(mod)
  if Namespace.at(mod) 
    v = Namespace.at(mod).children.select {|x| x.is_a? ConstantObject }.
      collect {|x| "+ #{x.name}" } +
      Namespace.at(mod)[:attributes].collect {|k, v| "- #{k} [#{v[:read] ? 'R': ''}#{v[:write] ? 'W' : ''}]" }
    v.join("\\l")  
  end
end
def pubmeths(mod) 
  if Namespace.at(mod) 
    Namespace.at(mod).children.select {|x| x.is_a? MethodObject }.
      collect do |x| 
        next if Namespace.at(mod)[:attributes].has_key? x.name.gsub(/=$/,'')
        "#{x.scope == :class ? '+' : '-'} #{x.name.gsub(/([<>])/,'\\\1')}" 
      end.compact.join("\\l") 
  end 
end
def full(b) $full ? "|#{consts(b)}\\l|#{pubmeths(b)}\\l" : "" end
def node(a,b) "#{idname(b)} [label=\"{#{ismod(b)} #{a}#{full(b)}}\" rank=sink]" end

$unresolved_classes, $edges, $mixins = {}, {}, {}
def enter_module(mod, l = 1)
  s(l) + "subgraph cluster_#{idname(mod.path)} {\n" +
  s(l+1) + "label = \"#{mod.name}\"; labelloc=b;\n" +
  mod.children.map do |submod|
    if submod.is_a? ModuleObject
      $unresolved_classes[submod.path] = false
      if $empty_modules && submod.children.select {|x| [ClassObject, ModuleObject].include? x.class }.empty?
        s(l+1) + node(submod.name, submod.path) + ";\n"
      else
        enter_module(submod, l+1)
      end
    elsif submod.is_a? ClassObject
      superclass = Namespace.find_from_path(submod.parent, submod.superclass)
      unless superclass.is_a? ClassObject
        superclass = submod.superclass 
      else
        superclass = superclass ? superclass.path : submod.superclass
      end
      superclass = submod.superclass if superclass == submod.path
      superclass.gsub!(/^::/,'') # TODO: Move this to Namespace
      submod.full_mixins.each do |mix| 
        $unresolved_classes[mix] = true unless $unresolved_classes.has_key?(mix)
        $mixins[idname(mix)] = idname(submod.path) 
      end if $dependencies
      $unresolved_classes[superclass] = true unless $unresolved_classes.has_key?(superclass)
      $unresolved_classes[submod.path] = false
      $edges[submod.path] = superclass
      s(l+1) + node(submod.name, submod.path) + ";"
    end
  end.compact.join("\n") + "\n" + 
  s(l) + "}\n"
end

subgraphs = enter_module(Namespace.at(''))
$unresolved_classes.delete("Object")
resolved = $unresolved_classes.map {|k,v| s(2) + node(k, k) + ";" if v }.compact
edges = $edges.map {|a,b| s(1) + "#{idname(a)} -> #{idname(b)};" unless b == "Object" }.compact
mixins = $mixins.map {|a,b| s(1) + "#{a} -> #{b} [style=dashed rank=sink];" }
output =  "digraph yard {\n"
output << s(1) + "graph [rankdir=BT rank=sink outputMode=nodesfirst packMode=\"graph\" splines=true];\n"
output << s(1) + "node [shape=record rank=sink rankType=sink];\n"
output << s(1) + "subgraph unknown {\n"
output << resolved.join("\n") + "\n"
output << s(1) + "}\n\n"
output << subgraphs
output << edges.join("\n") + "\n"
output << mixins.join("\n") + "\n" if $dependencies
output << "}\n"
puts output
