<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="style.css" type="text/css" charset="utf-8" />
<link rel="stylesheet" href="custom.css" type="text/css" charset="utf-8" />
<link rel="stylesheet" href="syntax_highlight.css" type="text/css" charset="utf-8" />

    <title>GETTING_STARTED.markdown</title>
  </head>
  <body>
    <div id="content">
      <div class="section docstring readme">
        <h1>Getting Started with YARD</h1>

<p>There are a few ways which YARD can be of use to you or your project. This
document will cover the most common ways to use YARD:</p>

<ul>
<li><a href="#docing">Documenting Code with YARD</a></li>
<li><a href="#using">Using YARD to Generate Documentation</a></li>
<li><a href="#extending">Extending YARD</a></li>
<li><a href="#templating">Templating YARD</a></li>
</ul>


<p><a name="docing"></a></p>

<h1>Documenting Code with YARD</h1>

<p>By default, YARD is compatible with the same RDoc syntax most Ruby developers
are already familiar with. However, one of the biggest advantages of YARD is
the extended meta-data syntax, commonly known as "tags", that you can use
to express small bits of information in a structured and formal manner. While
RDoc syntax expects you to describe your method in a completely free-form
manner, YARD recommends declaring your parameters, return types, etc. with
the <code>@tag</code> syntax, which makes outputting the documentation more consistent
and easier to read. Consider the RDoc documentation for a method reverse:</p>

<pre class="code"><span class='comment'># Converts the object into textual markup given a specific `format` 
</span><span class='comment'># (defaults to `:html`)
</span><span class='comment'>#
</span><span class='comment'># == Parameters:
</span><span class='comment'># format::
</span><span class='comment'>#   A Symbol declaring the format to convert the object to. This 
</span><span class='comment'>#   can be `:text` or `:html`.
</span><span class='comment'>#
</span><span class='comment'># == Returns:
</span><span class='comment'># A string representing the object in a specified
</span><span class='comment'>#
</span><span class='comment'># format.
</span><span class='kw'>def</span> <span class='id to_format'>to_format</span><span class='lparen'>(</span><span class='id format'>format</span> <span class='op'>=</span> <span class='symbol'>:html</span><span class='rparen'>)</span>
  <span class='comment'># reverse the string
</span><span class='kw'>end</span>
</pre>

<p>While this may seem easy enough to read and understand, it's hard for a machine
to properly pull this data back out of our documentation. Also we've tied our
markup to our content, and now our documentation becomes hard to maintain if
we decide later to change our markup style (maybe we don't want the ":" suffix
on our headers anymore).</p>

<p>In YARD, we would simply define our method as:</p>

<pre class="code"><span class='comment'># Converts the object into textual markup given a specific format.
</span><span class='comment'>#
</span><span class='comment'># @param [Symbol] format the format type, `:text` or `:html`
</span><span class='comment'># @return [String] the object converted into the expected format.
</span><span class='kw'>def</span> <span class='id to_format'>to_format</span><span class='lparen'>(</span><span class='id format'>format</span> <span class='op'>=</span> <span class='symbol'>:html</span><span class='rparen'>)</span>
<span class='kw'>end</span>
</pre>

<p>Using tags we can add semantic metadata to our code without worrying about
presentation. YARD will handle presentation for us when we decide to generate
documentation later.</p>

<h2>Adding Tags to Documentation</h2>

<p>The tag syntax that YARD uses is the same @tag-style syntax you may have seen
if you've ever coded in Java, Python, PHP, Objective-C or a myriad of other
languages. The following tag adds an author tag to your class:</p>

<pre class="code"><span class='comment'># @author Loren Segal
</span><span class='kw'>class</span> <span class='const'>MyClass</span>
<span class='kw'>end</span>
</pre>

<p>To allow for large amounts of text, the @tag syntax will recognize any indented
lines following a tag as part of the tag data. For example:</p>

<pre class="code"><span class='comment'># @deprecated Use {#my_new_method} instead of this method because
</span><span class='comment'>#   it uses a library that is no longer supported in Ruby 1.9.
</span><span class='comment'>#   The new method accepts the same parameters.
</span><span class='kw'>def</span> <span class='id mymethod'>mymethod</span>
<span class='kw'>end</span>
</pre>

<h2>Declaring Types</h2>

<p>Some tags also have an optional "types" field which let us declare a list of
types associated with the tag. For instance, a return tag can be declared
with or without a types field.</p>

<pre class="code"><span class='comment'># @return [String, nil] the contents of our object or nil
</span><span class='comment'>#   if the object has not been filled with data.
</span><span class='kw'>def</span> <span class='id validate'>validate</span><span class='semicolon'>;</span> <span class='kw'>end</span>

<span class='comment'># We don't care about the &quot;type&quot; here:
</span><span class='comment'># @return the object
</span><span class='kw'>def</span> <span class='id to_obj'>to_obj</span><span class='semicolon'>;</span> <span class='kw'>end</span>
</pre>

<p>The list of types is in the form <code>[type1, type2, ...]</code> and is mostly free-form,
so we can also specify duck-types or constant values. For example:</p>

<pre class="code"><span class='comment'># @param [#to_s] argname any object that responds to `#to_s`
</span><span class='comment'># @param [true, false] argname only true or false
</span></pre>

<p>Note the the latter example can be replaced by the meta-type "Boolean", and
numeric types can be replaced by "Number". These meta-types are by convention
only, but are recommended.</p>

<p>List types can be specified in the form <code>CollectionClass&lt;ElementType, ...&gt;</code>.
For instance, consider the following Array that holds a set of Strings and
Symbols:</p>

<pre class="code"><span class='comment'># @param [Array&lt;String, Symbol&gt;] list the list of strings and symbols.
</span></pre>

<p><a name="taglist"></a></p>

<h2>List of Tags</h2>

<p>A list of common tags and example usage is below:</p>

<ul>
<li><p><code>@author</code>: List the author(s) of a class/method</p>

<pre class="code">@author Full Name
</pre></li>
<li><p><code>@deprecated</code>: Marks a method/class as deprecated with an optional
reason.</p>

<pre class="code">@deprecated Describe the reason or provide alt. references here
</pre></li>
<li><p><code>@example</code>: Show an example snippet of code for an object. The
first line is an optional title.</p>

<pre class="code">@example Reverse a string
  &quot;mystring.reverse&quot; #=&gt; &quot;gnirtsym&quot;
</pre></li>
<li><p><code>@option</code>: Describe an options hash in a method. The tag takes the
name of the options parameter first, followed by optional types,
the option key name, an optional default value for the key and a
description of the option.</p>

<pre class="code"><span class='comment'># @param [Hash] opts the options to create a message with.
</span><span class='comment'># @option opts [String] :subject The subject
</span><span class='comment'># @option opts [String] :from ('nobody') From address
</span><span class='comment'># @option opts [String] :to Recipient email
</span><span class='comment'># @option opts [String] :body ('') The email's body 
</span><span class='kw'>def</span> <span class='id send_email'>send_email</span><span class='lparen'>(</span><span class='id opts'>opts</span> <span class='op'>=</span> <span class='lbrace'>{</span><span class='rbrace'>}</span><span class='rparen'>)</span>
<span class='kw'>end</span> 
</pre></li>
<li><p><code>@overload</code>: Describe that your method can be used in various
contexts with various parameters or return types. The first
line should declare the new method signature, and the following
indented tag data will be a new documentation string with its
own tags adding metadata for such an overload.</p>

<pre class="code"><span class='comment'># @overload set(key, value)
</span><span class='comment'>#   Sets a value on key
</span><span class='comment'>#   @param [Symbol] key describe key param
</span><span class='comment'>#   @param [Object] value describe value param
</span><span class='comment'># @overload set(value)
</span><span class='comment'>#   Sets a value on the default key `:foo`
</span><span class='comment'>#   @param [Object] value describe value param
</span><span class='kw'>def</span> <span class='id set'>set</span><span class='lparen'>(</span><span class='op'>*</span><span class='id args'>args</span><span class='rparen'>)</span>
<span class='kw'>end</span>
</pre></li>
<li><p><code>@param</code>: Defines method parameters</p>

<pre class="code">@param [optional, types, ...] argname description
</pre></li>
<li><p><code>@raise</code>: Describes an Exception that a method may throw</p>

<pre class="code">@raise [ExceptionClass] description
</pre></li>
<li><p><code>@return</code>: Describes return value of method</p>

<pre class="code">@return [optional, types, ...] description
</pre></li>
<li><p><code>@see</code>: "See Also" references for an object. Accepts URLs or
other code objects with an optional description at the end.</p>

<pre class="code">@see http://example.com Description of URL
@see SomeOtherClass#method
</pre></li>
<li><p><code>@since</code>: Lists the version the feature/object was first added</p>

<pre class="code">@since 1.2.4
</pre></li>
<li><p><code>@todo</code>: Marks a TODO note in the object being documented</p>

<pre class="code">@todo Add support for Jabberwocky service
  There is an open source Jabberwocky library available 
  at http://somesite.com that can be integrated easily
  into the project.
</pre></li>
<li><p><code>@version</code>: Lists the version of a class, module or method</p>

<pre class="code">@version 1.0
</pre></li>
<li><p><code>@yield</code>: Describes the block. Use types to list the parameter
names the block yields.</p>

<pre class="code"># for block {|a, b, c| ... }
@yield [a, b, c] Description of block
</pre></li>
<li><p><code>@yieldparam</code>: Defines parameters yielded by a block</p>

<pre class="code">@yieldparam [optional, types, ...] argname description
</pre></li>
<li><p><code>@yieldreturn</code>: Defines return type of a block</p>

<pre class="code">@yieldreturn [optional, types, ...] description
</pre></li>
</ul>


<h2>Other Extended Syntax</h2>

<p><strong>Reference Tags</strong></p>

<p>To minimize rewriting of documentation and to ease maintenance, a special
tag syntax is allowed to reference tags from other objects. Doing this allows
a tag to be added as meta-data for multiple objects. A full example of this
syntax is found in the <a href="TAGS.markdown.html#reftags" title="TAGS.markdown">TAGS.markdown</a> file.</p>

<p><strong>Inter-Document Links</strong></p>

<p>YARD supports a special syntax to link to other code objects or files.
The syntax is <code>{ObjectName#method OPTIONAL_TITLE}</code>. This syntax is acceptable
anywhere in documentation with the exception of the @see tag, which
automatically links its data.</p>

<p><a name="using"></a></p>

<h1>Using YARD to Generate Documentation</h1>

<p>Obviously since YARD is a documentation tool, one of its primary goals is
to generate documentation for a variety of formats, most commonly HTML. The
<code>yardoc</code> tool that is installed with YARD allows you to quickly export code
documentation to HTML document files. In addition to this, YARD ships with
two more tools allowing you to quickly view <code>ri</code>-style documentation for
a specific class or method as well as an extra tool to generate UML diagrams
for your code using <a href="http://www.graphviz.org">Graphviz</a>. An overview of these tools can
be found in the <a href="README.markdown.html" title="README">README</a> under the Usage section.</p>

<p><a name="extending"></a></p>

<h1>Extending YARD</h1>

<p>There are many ways to extend YARD to support non-standard Ruby syntax (DSLs),
add new meta-data tags or programmatically access the intermediate metadata
and documentation from code. An overview of YARD's full architecture can be
found in the <a href="OVERVIEW.markdown.html" title="OVERVIEW.markdown">OVERVIEW.markdown</a> document.</p>

<p>For information on adding support for Ruby DSLs, see the <a href="HANDLERS.markdown.html" title="HANDLERS.markdown">HANDLERS.markdown</a>
and <a href="PARSER.markdown.html" title="PARSER.markdown">PARSER.markdown</a> architecture documents.</p>

<p>For information on adding extra tags, see <a href="TAGS.markdown.html" title="TAGS.markdown">TAGS.markdown</a>.</p>

<p>For information on accessing the data YARD stores about your documentation,
look at the <a href="CODE_OBJECTS.markdown.html" title="CODE_OBJECTS.markdown">CODE_OBJECTS.markdown</a> architecture document.</p>

<p><a name="templating"></a></p>

<h1>Templating YARD</h1>

<p>In many cases you may want to change the style of YARD's templates or add extra
information after extending it. The <a href="GENERATORS.markdown.html" title="GENERATORS.markdown">GENERATORS.markdown</a> architecture
document covers the basics of how YARD's templating system works.</p>
      </div>
    </div>
    <div id="yard_info">
  Generated on Friday, October 16 2009 at 12:40:30 AM by 
  <abbr class="yard" title="Yay! A Ruby Documentation Tool"><a href="http://yard.soen.ca">YARD</a></abbr> 
  0.2.3.5 (ruby-1.9.1).
</div>

  </body>
</html>